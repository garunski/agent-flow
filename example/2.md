
## Example: Adding OAuth2 Authentication — Extended Gap / Yellow Path

**User Request:** `"Add user authentication with OAuth2"`

---

### Step 1 — Codebase Analysis (Analyzer Agent)

The **Analyzer Agent** predicts all areas of the codebase impacted by OAuth2 authentication, including login endpoints, session management, and token handling. The execution system scans the repository, producing a structured map of affected files and functions. This analysis context is retained for future feedback loops.

---

### Step 2 — Documentation Gathering (Documenter Agent)

The **Documenter Agent** predicts the relevant documentation and external references needed for OAuth2 integration. The execution system retrieves the guides, library references, and examples. However, **some references are incomplete or outdated**, creating a **hidden gap** that is not immediately detected. The predicted documentation is passed to the Strategist Agent along with the code map.

---

### Step 3 — Integration Strategy (Strategist Agent)

The **Strategist Agent** produces an initial plan:

* Use OAuth2 Authorization Code flow with JWT tokens.
* Outline DB schema updates and endpoint modifications.
* Provide instructions for code implementation and testing.

The plan is passed to the Implementer Agent.

---

### Step 4 — Database Schema Design (Schema Designer Agent)

The **Schema Designer Agent** predicts necessary database changes and the execution system applies migrations. Output: updated schema and migration logs.

---

### Step 5 — Code Implementation (Implementer Agent)

The **Implementer Agent** produces the code and configuration changes for OAuth2 authentication. **Gap introduced:** automated tests are skipped, and some assumptions in documentation are ignored. Execution applies code, but the missing tests create risk for validation failures later.

---

### Step 6 — First Validation & Gap Detection (Checker Agent)

The **Checker Agent** runs validation:

* Unit tests, integration tests, and security checks.
* Detects that tests are missing and some documentation assumptions are incomplete.

**Action:** Checker sends **structured feedback to the Strategist Agent**, highlighting:

* Missing test coverage
* Incomplete or inaccurate documentation references

The Strategist Agent updates the plan and returns it to the Implementer.

---

### Step 7 — Second Implementation Iteration (Implementer Agent)

The Implementer applies the updated plan:

* Adds missing tests
* Attempts to follow documentation instructions
  Execution system applies changes and runs tests again.

**Problem:** Some documentation references still turn out to be incomplete or conflicting, causing the validation to fail again.

---

### Step 8 — Multiple Feedback Iterations (Strategist Agent)

The **Checker Agent** returns validation results to the Strategist multiple times. After several iterations:

* The Strategist realizes the underlying documentation is insufficient.
* The plan itself is no longer valid without additional analysis.

**Action:** The Strategist triggers a **full feedback loop back to the Analyzer Agent** to **re-analyze the codebase and gather updated documentation**, effectively restarting the plan with enriched context.

---

### Step 9 — Restarted Analysis & Documentation

* Analyzer re-scans the repository with updated insights.
* Documenter retrieves corrected and complete documentation.
* Strategist produces a revised, valid plan.

From this point, the Implementer can proceed with code and test implementation, with proper context and documentation, leading eventually to a fully validated, green-path outcome.

---

### ✅ Key Points — Extended Feedback Loop

* **Multiple iterations with Strategist**: Checker validation may trigger repeated plan updates without going straight to implementation.
* **Restart to Analyzer**: If assumptions or documentation are fundamentally missing, the system loops **back to the start**, ensuring robust reasoning.
* **Context reuse**: Analyzer and Strategist agents maintain reasoning history to avoid losing prior insights.
* **Process-driven & small context**: Each agent sees only its relevant input, but loops allow **progressive refinement and error correction**.
* **Dynamic adaptation**: The system detects when incremental fixes are insufficient and escalates to a higher-level reasoning step.

