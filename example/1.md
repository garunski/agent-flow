
## Example: Multi-Agent Orchestration with Gap Detection

**User Request:** `"Add user authentication with OAuth2"`

---

### 1. **Predicted Steps by Agents**

1. **Analyzer Agent** → Predicts impacted code areas.
2. **Documenter Agent** → Predicts relevant documentation and API references.
3. **Strategist Agent** → Predicts OAuth2 integration approach.
4. **Schema Designer Agent** → Predicts DB schema changes required.
5. **Implementer Agent** → Predicts code and configuration changes.

---

### 2. **Execution & Automated Testing**

* Execution system runs each implementer step with **automated tests**.
* If tests **pass**, proceed to **Checker Agent**.
* If tests **fail**, execution errors are **fed back to the original agent** (maintaining the context of analysis or implementation) for correction.

---

### 3. **Validation & Gap Detection**

1. **Checker Agent** evaluates implemented code/config:

   * Checks compliance rules, security, business logic, and integration correctness.
   * Identifies **missing steps or incomplete implementation** (gaps) that the Implementer missed.
2. **Gap Prompt Generation**:

   * A specialized **prompt is automatically generated** for the Implementer agent, describing:

     * What was missed
     * Context from original prediction
     * Which part of the implementation to correct
   * This allows the Implementer to **produce updated code/config** focused on the gaps without redoing everything.

---

### 4. **Iterative Loop**

* After gap fixes:

  * Execution system reruns tests on the updated implementation.
  * Checker re-validates.
  * If new gaps appear → repeat **prompt generation → fix → test → validate**.
* Loop continues until **all validation gates pass**.

---

### 5. **Verifier & Finalization**

* **Verifier Agent** predicts final verification steps, ensures:

  * All gaps have been addressed
  * Code/config passes all tests
  * Compliance/security standards are met
* Execution system applies final run and generates **audit report**.

---

### 6. **Key Advantages**

* **Focused gap-fixing**: Only missing pieces are fixed, no unnecessary rework.
* **Context reuse**: Implementer retains original analysis and strategy context, improving correctness.
* **Process-driven validation**: Testing + Checker + Gap prompts ensures **robust, iterative refinement**.
* **Small context for agents**: Each agent operates in a limited view, even across multiple iterations.

